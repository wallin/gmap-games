window.GM = window.GM || {};

var malmo = {
  "type": "Feature",
  "bbox": [12.7153, 55.4892, 13.1500, 55.6797],
  "properties": {
    "name": "Malmö"
  },
  "geometry": {
    "type": "MultiPolygon",
    "coordinates": [[13.1249, 55.6078], [13.1154, 55.6077], [13.1151, 55.6081], [13.1139, 55.6084], [13.1134, 55.6073], [13.1104, 55.6057], [13.1094, 55.6052], [13.1086, 55.6046], [13.1075, 55.6040], [13.1039, 55.6049], [13.0997, 55.6047], [13.0959, 55.6048], [13.0956, 55.6059], [13.0928, 55.6087], [13.0918, 55.6104], [13.0899, 55.6103], [13.0889, 55.6098], [13.0889, 55.6119], [13.0873, 55.6116], [13.0872, 55.6118], [13.0834, 55.6112], [13.0816, 55.6135], [13.0800, 55.6132], [13.0787, 55.6135], [13.0765, 55.6136], [13.0742, 55.6123], [13.0711, 55.6120], [13.0684, 55.6115], [13.0682, 55.6118], [13.0677, 55.6118], [13.0672, 55.6120], [13.0669, 55.6126], [13.0676, 55.6127], [13.0672, 55.6133], [13.0681, 55.6140], [13.0682, 55.6150], [13.0677, 55.6176], [13.0680, 55.6189], [13.0697, 55.6192], [13.0685, 55.6219], [13.0662, 55.6282], [13.0610, 55.6301], [13.0629, 55.6317], [13.0517, 55.6358], [13.0402, 55.6378], [13.0171, 55.6410], [13.0171, 55.6410], [12.9724, 55.6797], [12.9724, 55.6797], [12.8765, 55.6642], [12.8765, 55.6642], [12.8959, 55.6433], [12.8814, 55.6142], [12.7294, 55.5409], [12.7153, 55.4892], [12.7153, 55.4892], [12.9230, 55.5044], [12.9230, 55.5044], [13.0477, 55.5142], [13.0569, 55.5254], [13.1086, 55.5272], [13.1086, 55.5272], [13.1374, 55.5452], [13.1211, 55.5616], [13.1500, 55.5714], [13.1487, 55.6041], [13.1487, 55.6041], [13.1249, 55.6078]]
  }
};

var storp = {
  "type": "Feature",
  "bbox": [13.0997, 55.6041, 13.3556, 55.7052],
  "properties": {
    "name": "Staffanstorp"
  },
  "geometry": {
    "type": "MultiPolygon",
    "coordinates": [[13.2964, 55.6064], [13.2806, 55.6203], [13.2610, 55.6233], [13.2367, 55.6152], [13.1982, 55.6180], [13.1880, 55.6057], [13.1487, 55.6041], [13.1487, 55.6041], [13.1249, 55.6078], [13.1249, 55.6078], [13.1302, 55.6179], [13.1305, 55.6202], [13.1248, 55.6204], [13.1252, 55.6211], [13.1246, 55.6216], [13.1235, 55.6209], [13.1228, 55.6208], [13.1212, 55.6203], [13.1207, 55.6208], [13.1196, 55.6207], [13.1192, 55.6200], [13.1161, 55.6194], [13.1156, 55.6201], [13.1139, 55.6202], [13.1134, 55.6211], [13.1121, 55.6211], [13.1108, 55.6261], [13.1095, 55.6317], [13.1126, 55.6324], [13.1153, 55.6337], [13.1193, 55.6335], [13.1203, 55.6353], [13.1199, 55.6355], [13.1201, 55.6362], [13.1168, 55.6369], [13.1183, 55.6384], [13.1190, 55.6401], [13.1197, 55.6441], [13.1218, 55.6443], [13.1233, 55.6497], [13.1272, 55.6481], [13.1335, 55.6528], [13.1319, 55.6534], [13.1366, 55.6554], [13.1311, 55.6585], [13.1185, 55.6583], [13.1167, 55.6620], [13.1120, 55.6662], [13.1120, 55.6662], [13.1158, 55.6736], [13.1013, 55.6744], [13.1002, 55.6848], [13.0997, 55.6969], [13.1181, 55.7037], [13.1181, 55.7037], [13.1401, 55.7052], [13.1487, 55.6997], [13.1550, 55.6974], [13.1594, 55.6930], [13.1661, 55.6895], [13.1711, 55.6862], [13.1688, 55.6805], [13.1739, 55.6800], [13.1779, 55.6793], [13.1829, 55.6770], [13.2067, 55.6751], [13.2784, 55.6881], [13.3180, 55.6482], [13.3508, 55.6363], [13.3556, 55.6178], [13.3350, 55.6124], [13.3181, 55.6223], [13.2964, 55.6064]]
  }
};

var vell = {
  "type": "Feature",
  "bbox": [12.6106, 55.1350, 13.1722, 55.5272],
  "properties": {
    "name": "Vellinge"
  },
  "geometry": {
    "type": "MultiPolygon",
    "coordinates": [[13.1669, 55.4832], [13.1620, 55.4725], [13.1342, 55.4564], [13.1014, 55.4656], [13.0800, 55.4648], [13.0697, 55.4663], [13.0520, 55.4645], [13.0598, 55.4349], [13.0711, 55.4250], [13.0432, 55.4183], [13.0136, 55.3807], [13.0136, 55.3807], [12.8761, 55.1350], [12.8761, 55.1350], [12.7949, 55.1667], [12.6772, 55.2500], [12.6389, 55.3083], [12.6420, 55.3373], [12.6420, 55.3373], [12.6106, 55.4317], [12.6106, 55.4317], [12.7153, 55.4892], [12.7153, 55.4892], [12.9230, 55.5044], [12.9230, 55.5044], [13.0477, 55.5142], [13.0569, 55.5254], [13.1086, 55.5272], [13.1086, 55.5272], [13.1432, 55.4909], [13.1722, 55.4891], [13.1669, 55.4832]]
  }
};


/***** Logging ******/

GM.log = function (msg, lvl) {
  lvl = lvl || GM.log.INFO;
  if (lvl >= GM.log.level) {
    console.log(msg);
  }
};

GM.log.INFO  = 0;
GM.log.WARN  = 1;
GM.log.ERROR = 2;

GM.log.level = GM.log.INFO;


GM.MARKER_CLASS  = 'mapMarker';
GM.CLUSTER_CLASS = 'clusterMarker';

GM.Boundary = function (name, coordSet) {
  this.name = name;
  var poly = this.polygon = [];
  for (var i = 0, ii = coordSet.length; i < ii; i++) {
    var polyCoords = coordSet[i];
    poly[i] = [];
    for (var j = 0, jj = polyCoords.length; j < jj; j++) {
      var el = polyCoords[j];
      poly[i].push({
        lon: el[0],
        lat: el[1]
      });
    }
  }
};


/****** Geo helpers ******/
GM.Helpers = {
  //http://www.movable-type.co.uk/scripts/latlong.html
  distanceBetweenPoints: function (p1, p2) {
    if (!p1 || !p2) {
      return 0;
    }

    var R = 6371; // Radius of the Earth in km
    var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
    var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    var d = R * c;
    return d;
  }
};

GM.createMap = function (lat, lon, zoomlevel, id) {
  var opts = {
    center: new google.maps.LatLng(lat, lon),
    zoom: zoomlevel,
    scrollwheel: false,
    streetViewControl: false,
    mapTypeId: google.maps.MapTypeId.ROADMAP
  };
  var el = document.getElementById(id);
  return new google.maps.Map(el, opts);
};





// Clusterer will create a new overlay for displaying it's items
// It is constructed with a google map instance as parameter
GM.mapClusterer = function (controller) {
  this.map = controller;
  this.clusters = [];
  this.clusterLookup = {}; // Find out which cluster a marker belongs to
  this.markers = null;
  this.overlay = null;
  this.gridSize = 120;
};

GM.mapClusterer.prototype.moveMarkersToClusters = function (markers, clusters, lookup) {
  for (var i = 0, ii = markers.length; i < ii; i++) {
    var m = markers[i];
    var c = clusters[lookup[m.id]];
    if (c) {
      m.realPos = m.pos;
      m.pos = new google.maps.LatLng(c.pos.lat(), c.pos.lng());
    }
  }
  this.map.moveMarkers(markers);
};

// https://engineering.purdue.edu/~milind/docs/rt08.pdf
// http://nlp.stanford.edu/IR-book/html/htmledition/hierarchical-agglomerative-clustering-1.html
// http://nlp.stanford.edu/IR-book/html/htmledition/cluster-cardinality-in-k-means-1.html#eqn:aicsimple
GM.mapClusterer.prototype.createKMeansClusters = function (markers) {
  var clusters  = [];
  var vectors = [];
  var labels = [];
  _.each(markers, function (item) {
    vectors.push([item.pos.lat(), item.pos.lng()]);
    labels.push(item.id);
  });
  var t1 = new Date();
  var root = this.clusterData = figue.kmeans(10, vectors);
  GM.log('K-means complete after: ' + (new Date() - t1));
  t1 = new Date();
  console.log(figue.agglomerate(labels, vectors, figue.EUCLIDIAN_DISTANCE, figue.SINGLE_LINKAGE));
  GM.log('Agglo complete after: ' + (new Date() - t1));
  GM.log(root);
  var id = 0;
  for (var i = 0, ii = root.centroids.length; i < ii; i++) {
    var item = root.centroids[i];
    clusters.push(
      new GM.ThinMarker(
        'cluster_' + (id++),
        new google.maps.LatLng(item[0], item[1]),
        null,
        GM.CLUSTER_CLASS
      )
    );
  }
  this.markers = markers;
  this.clusters = clusters;
};

// Create bounds extended to grid size
GM.mapClusterer.prototype.getExtendedBounds = function (bounds) {
  var projection = this.map.getProjection();

  // Turn the bounds into latlng.
  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
      bounds.getNorthEast().lng());
  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
      bounds.getSouthWest().lng());

  // Convert the points to pixels and the extend out by the grid size.
  var trPix = projection.fromLatLngToDivPixel(tr);
  trPix.x += this.gridSize;
  trPix.y -= this.gridSize;

  var blPix = projection.fromLatLngToDivPixel(bl);
  blPix.x -= this.gridSize;
  blPix.y += this.gridSize;

  // Convert the pixel points back to LatLng
  var ne = projection.fromDivPixelToLatLng(trPix);
  var sw = projection.fromDivPixelToLatLng(blPix);

  // Extend the bounds to contain the new bounds.
  bounds.extend(ne);
  bounds.extend(sw);

  return bounds;
};

GM.mapClusterer.prototype.addToClosestCluster = function (clusters, lookup, marker, force) {
  var distance = Infinity;
  var clusterToAddTo = null;
  var idx = 0;
  for (var i = 0, cluster; cluster = clusters[i]; i++) {
    var center = cluster.pos;
    if (center) {
      var d = GM.Helpers.distanceBetweenPoints(center, marker.pos);
      if (d < distance) {
        distance = d;
        idx = i;
        clusterToAddTo = cluster;
      }
    }
  }

  if (force || (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker))) {
    clusterToAddTo.addMarker(marker);
  } else {
    idx = clusters.length;
    cluster = new GM.ThinCluster(this, idx, null, null, GM.CLUSTER_CLASS);
    cluster.addMarker(marker);
    clusters.push(cluster);
  }
  lookup[marker.id] = idx;
};

GM.mapClusterer.prototype.createClusters = function (markers, clusters) {
  var forceExisting = clusters != null;
  clusters = clusters || [];
  var lookup = {};

  var mapBounds = new google.maps.LatLngBounds(this.map.map.getBounds().getSouthWest(),
                                               this.map.map.getBounds().getNorthEast());
  var bounds = this.getExtendedBounds(mapBounds);

  var t1 = new Date();

  for (var i = 0, marker; marker = markers[i]; i++) {
    if (!marker.isAdded && bounds.contains(marker.pos)) {
      this.addToClosestCluster(clusters, lookup, marker, forceExisting);
    }
  }

  GM.log('Created ' + clusters.length + ' clusters from ' + markers.length + ' markers in ' + (new Date() - t1) + 'ms');

  return { clusters: clusters, lookup: lookup };
};

GM.mapClusterer.prototype.updateClusters = function (markers) {
  this.markers = markers;
  var oldClusters = this.clusters;
  // Calculate new cluster positions
  var rv = this.createClusters(markers);
  this.clusters = rv.clusters;
  this.clusterLookup = rv.lookup;

  if (this.overlay) {
    var overlay = this.overlay;
    _.defer(function () {
      overlay.setMap(null);
    });
  }
  this.overlay = new GM.MarkerOverlay(this.map.map, this.clusters);

};

GM.mapClusterer.prototype.createLayer = function (markers) {
  var rv = this.createClusters(markers);
  var self = this;
  this.markers = markers;
  this.clusters = rv.clusters;
  this.clusterLookup = rv.lookup;

  _.defer(function () {
    self.moveMarkersToClusters(markers, rv.clusters, rv.lookup);
  });

  this.overlay = new GM.MarkerOverlay(this.map.map, rv.clusters);
  return this.overlay;
};

// Remove cluster overlay and create a new markerlayer based on current clusters
GM.mapClusterer.prototype.removeLayer = function () {
  var markers = [];
  for (var i = 0, ii = this.clusters.length; i < ii; i++) {
    var c = this.clusters[i];
    for (var j = 0, jj = c.markers.length; j < jj; j++) {
      var m = c.markers[j];
      markers.push(m);
      m.realPos = m.realPos || m.pos;
      m.pos = c.pos;
      m.isAdded = false;
    }
  }
  var layer = new GM.MarkerOverlay(this.map.map, markers);
  var self = this;
  _.defer(function () {
    self.map.moveMarkers(self.markers, true);
  });
  if (this.overlay) {
    this.overlay.setMap(null);
    this.overlay = null;
  }
  this.clusters = [];
  this.clusterLookup = null;

  return layer;
};


/******************************************************************************/

GM.mapController = {
  map: null,
  markers: null,
  activeBoundaryPoints: null,
  activeBoundaryPolygon: null,
  objectOverlay: null,
  clusterOverlay: null,
  zoomLevel: null,
  zoomDiff: null,

  _isMoving: false,

  /****** Initialization ******/
  init: function (map, data, el) {
    _.bindAll(this, 'onDragStart', 'onClick', 'onIdle', 'onBoundsChanged', 'onZoomEnd');
    this.map = map;
    this.data = data;
    this.initHelper();
    this.clusterer = new GM.mapClusterer(this);
    // Setup event handlers
    google.maps.event.addListener(this.map, 'dragstart', this.onDragStart);
    google.maps.event.addListener(this.map, 'bounds_changed', this.onBoundsChanged);
    google.maps.event.addListener(this.map, 'idle', this.onIdle);
    google.maps.event.addListener(this.map, 'zoom_changed', this.onZoomEnd);
    google.maps.event.addDomListener(document.getElementById(el), 'click', this.onClick);
    return this;
  },

  initHelper: function () {
    this._helper = new google.maps.OverlayView();
    this._helper.draw = $.noop;
    this._helper.onAdd = $.noop;
    this._helper.onRemove = $.noop;
    this._helper.setMap(this.map);
  },

  /****** Map event handlers *******/
  onDragStart: function () {
    GM.log('begin map move');
    this._isMoving = true;
  },

  onZoomEnd: function (z1, z2) {
    GM.log('Map zoomed in from ' + z1 + ' to ' + z2);
  },

  onIdle: function () {
    GM.log('map idle');
    this.zoomDiff = this.map.getZoom() - this.zoomLevel;
    this.zoomLevel = this.map.getZoom();
    if (this._isMoving) {
      this.redraw();
      this._isMoving = false;
    }
  },

  onClick: function (e) {
    // Check if we hit a marker
    if (!this._isMoving && e && e.target && e.target.className) {
      switch (e.target.className) {
      case GM.CLUSTER_CLASS:
        GM.log('Cluster clicked');
        break;
      case GM.MARKER_CLASS:
        GM.log('Marker clicked');
        break;
      }
      GM.log(e);
    }
  },

  onBoundsChanged: function () {
    this._isMoving = true;
  },

  /****** Helpers ******/
  getProjection: function () {
    return this._helper.getProjection();
  },

  fromLatLngToDivPixel: function (p) {
    return this._helper.getProjection().fromLatLngToDivPixel(p);
  },

  /****** Map operations ******/
  redraw: function () {
    GM.log('redraw map');
    var bounds = this.map.getBounds();
    var ne = bounds.getNorthEast();
    var sw = bounds.getSouthWest();
    this.markers = this.data.requestBB(sw.lat(), sw.lng(), ne.lat(), ne.lng());
    if (this.clusterOverlay) {
      this.updateClusterLayer();
    }
    else {
      this.updateMarkers();
    }
  },


  zoomToBounds: function (bounds) {
    this.map.fitBounds(bounds);
  },

  /****** Marker operations ******/
  updateMarkers: function (markers) {
    var newOverlay = new GM.MarkerOverlay(this.map, this.markers);
    if (this.objectOverlay) {
      var overlay = this.objectOverlay;
      _.defer(function () {
        overlay.setMap(null);
      });
    }
    this.objectOverlay = newOverlay;

  },

  moveMarkers: function (markers, reverse) {
    for (var i = 0, ii = markers.length; i < ii; i++) {
      var mrk = markers[i];
      var currentMarker = document.getElementById(mrk.id);
      if (currentMarker) {
        if (reverse) {
          var s = mrk.pos;
          mrk.pos = mrk.realPos;
          mrk.realPos = s;
        }
        var pos = this.fromLatLngToDivPixel(mrk.pos);
        currentMarker.style.left = pos.x + 'px';
        currentMarker.style.top = pos.y + 'px';
      }
    }

  },

  /****** Cluster operations ******/
  toggleClusterLayer: function () {
    if (this.clusterOverlay) {
      if (this.objectOverlay) {
        this.objectOverlay.setMap(null);
      }
      this.objectOverlay = this.removeClusterLayer();
    }
    else {
      this.addClusterLayer();
    }
  },
  addClusterLayer: function () {
    this.clusterOverlay = this.clusterer.createLayer(this.markers);
    var self = this;
    _.delay(function () {
      if (self.objectOverlay) {
        self.objectOverlay.setMap(null);
      }
    }, 700);
  },

  updateClusterLayer: function () {
    this.clusterer.updateClusters(this.markers);
  },

  removeClusterLayer: function () {
    this.clusterOverlay = null;
    return this.clusterer.removeLayer();
  },

  /****** Boundary mask operations  ******/
  setBounds: function (boundary) {
    this.activeBoundaryPoints = boundary == null ? null : boundary.polygon;
  },

  drawBounds: function () {
    if (this.activeBoundaryPoints == null) {
      return;
    }
    this.clearBounds();
    var shadePoly = [[
      new google.maps.LatLng(-89, -50),
      new google.maps.LatLng(-89, 80),
      new google.maps.LatLng(89, 80),
      new google.maps.LatLng(89, -50)
    ]];
    for (var i = 0, len = this.activeBoundaryPoints.length; i < len; i++) {
      var item = this.activeBoundaryPoints[i];
      var holePoly = [];
      for (var j = 0, jj = item.length; j < jj; j++) {
        var c = item[j];
        holePoly.push(new google.maps.LatLng(c.lat, c.lon));
      }
      holePoly.reverse();
      shadePoly.push(holePoly);
    }

    this.activeBoundaryPolygon = new google.maps.Polygon({
      paths: shadePoly,
      fillColor: "#aa7733",
      fillOpacity: 0.5,
      strokeWeight: 1,
      strokeColor: "#aa7733",
      strokeOpacity: 0.8,
      map: this.map,
      zIndex: 0
    });
  },
  clearBounds: function () {
    if (this.activeBoundaryPolygon) {
      this.activeBoundaryPolygon.setMap(null);
    }
  }
};


GM.DataController = Backbone.Collection.extend({
  initialize: function () {
    _.bindAll(this, 'requestBB');
  },
  requestBB: function (sw_lat, sw_lon, ne_lat, ne_lon) {
    var markers = [];
    this.each(function (item, i) {
      item = item.attributes;
      if (item.lat > sw_lat && item.lat < ne_lat &&
          item.lon > sw_lon && item.lon < ne_lon) {
        markers.push(new GM.ThinMarker(
          'item_' + i,
          new google.maps.LatLng(item.lat, item.lon),
          null,
          GM.MARKER_CLASS
        ));
      }
    });
    return markers;
  }
});

/******************************************************************************/

$(function () {
  var map = GM.createMap(61.588047, 14.000946, 5, 'gmap');
  var data = new GM.DataController();
  var c = GM.mapController.init(map, data, 'gmap');
  data.reset(munis);


  var mlm = new GM.Boundary('Malmö', [ malmo.geometry.coordinates, storp.geometry.coordinates]);
  c.setBounds(mlm);
  c.drawBounds();


  $('#animate').click(function () {
    c.toggleClusterLayer();
  });

});


/******************************************************************************/

GM.MarkerOverlay = function (map, markers) {
  this.map = map;
  this.setMap(map);
  this.markers = markers;
};

GM.MarkerOverlay.prototype = new google.maps.OverlayView();

_.extend(GM.MarkerOverlay, Backbone.Events);

_.extend(GM.MarkerOverlay.prototype, {
  onAdd: function () {
    this.el = document.createElement('div');
    var panes = this.getPanes();
    panes.floatPane.appendChild(this.el);
  },


  onRemove: function () {
    this.markers = [];
    this.el.parentNode.removeChild(this.el);
    this.el = null;
  },


  draw: function () {
    var i = this.markers.length;
    var HTML = '';
    var proj = this.getProjection();
    var pos;
    var marker;
    /* Hmmm... seems like string concatenation is fastest after all
     * http://jsperf.com/ultimate-string-concatenation-tests/3 */
    while (i--) {
      marker = this.markers[i];
      if (marker.visible) {
        pos = proj.fromLatLngToDivPixel(marker.pos);
        HTML += '<div id="' + marker.id + '" style="left:';
        HTML += pos.x;
        HTML += 'px; top:';
        HTML += pos.y;
        HTML += 'px;"';
        HTML += ' class="' + marker.className + '"';
        HTML += '>';
        if (marker.text) {
          HTML += marker.text;
        }
        HTML += '</div>';
      }
    }
    this.el.innerHTML = HTML;
  },


  getMarkers: function () {
    return this.markers;
  }
});

GM.ThinMarker = function (id, pos, text, className) {
  this.id = id;
  this.pos = pos;
  this.text = text;
  this.className = className;
  this.visible = true;
};
_.extend(GM.ThinMarker.prototype, {

  getPosition: function () {
    return this.pos;
  },

  getMap: $.noop,

  setMap: function (a) {
    this.visible = a === null ? false : true;
  }
});

/****** Cluster type *******/

GM.ThinCluster = function (clusterer, id, pos, text, className) {
  this.id = id;
  this.text = text;
  this.className = className;
  this.markers = [];
  this.pos = null;
  this.clusterer = clusterer;
  this.bounds = null;
  this.visible = true;
};


GM.ThinCluster.prototype.calculateBounds = function () {
  var bounds = new google.maps.LatLngBounds(this.pos, this.pos);
  this.bounds = this.clusterer.getExtendedBounds(bounds);
};

GM.ThinCluster.prototype.addMarker = function (marker) {
  if (!this.pos) {
    this.pos = marker.pos;
    this.calculateBounds();
  }

  // Calculate Average center
  var l = this.markers.length + 1;
  var lat = (this.pos.lat() * (l - 1) + marker.pos.lat()) / l;
  var lng = (this.pos.lng() * (l - 1) + marker.pos.lng()) / l;
  this.pos = new google.maps.LatLng(lat, lng);
  this.calculateBounds();

  marker.isAdded = true;
  this.markers.push(marker);
};

GM.ThinCluster.prototype.isMarkerInClusterBounds = function (marker) {
  return this.bounds.contains(marker.pos);
};
